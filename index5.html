<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Now playing == pixel</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <style>
    /* --- Layout & look ---------------------------------------------------- */
    :root { --gap: 10px; --panel-bg: #ffffff; --border: #d0d7de; }
    * { box-sizing: border-box; }
    body { font-family: Roboto, sans-serif; margin: 0; background:#f6f8fa; color:#0b0d11; }

    header { position: sticky; top: 0; z-index: 5; background: #0b0d11; color: #ffffff; padding: 12px 16px; box-shadow: 0 1px 0 #000000; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }

    .wrap { padding: 14px; display: grid; gap: var(--gap); }

    .controls { background: var(--panel-bg); border: 1px solid var(--border); border-radius: 10px; padding: 12px; display: grid; gap: 8px; }

    .row { display: flex; flex-wrap: wrap; gap: 10px 16px; align-items: center; }
    .row > label { display: inline-flex; align-items: center; gap: 6px; }
    .row input[type="number"] { width: 90px; padding: 6px 8px; }
    .row input[type="color"] { inline-size: 44px; block-size: 28px; padding: 0; border: 1px solid var(--border); border-radius: 6px; background: #ffffff; }
    .row input[type="checkbox"] { width: 18px; height: 18px; }

    button { cursor: pointer; border: 1px solid var(--border); background: #ffffff; padding: 8px 12px; border-radius: 8px; font-weight: 600; }
    button.primary { background: #0b5cff; border-color: #0b5cff; color: #ffffff; }

    /* Stage that can scroll when the art is large */
    .stage-shell { background: var(--panel-bg); border: 1px solid var(--border); border-radius: 10px; padding: 12px; }
    .stage-scroller { overflow: auto; max-height: 70vh; border: 1px dashed #e2e4e8; background: #ffffff; }

    /* The stack that holds the two canvases */
    #stage { position: relative; width: 0px; height: 0px; }
    canvas { position: absolute; inset: 0; display: block; image-rendering: pixelated; /* keeps hard edges when zoomed */ }
    #gridLayer { pointer-events: none; /* clicks go to paint layer */ }
  </style>
</head>
<body>
  <header><h1>Pixel Tool</h1></header>
  <main class="wrap">
    <section class="controls" aria-label="Controls">
      <div class="row">
        <label>Columns <input id="cols" type="number" min="1" max="200" value="24" /></label>
        <label>Rows <input id="rows" type="number" min="1" max="200" value="24" /></label>
        <!-- Cell size is fixed in the code (CELL_SIZE), on purpose.  -->
        <button id="build" class="primary">Create canvas</button>
        <button id="clear">Clear paint</button>
      </div>
      <div class="row">
        <label>Color <input id="color" type="color" value="#2b6cb0" /></label>
        <label><input id="eraser" type="checkbox" /> Eraser mode</label>
        <label><input id="showGrid" type="checkbox" checked /> Show grid</label>
        <label title="When you download, include the grid lines on the exported image."><input id="dlGrid" type="checkbox" checked/> Include grid in download</label>
        <button id="download">Download PNG</button>
      </div>
      <div style="opacity:.7;font-size:12px">Tips: Click‑drag to paint. Use “Eraser mode” to remove pixels. Nothing is saved. Reloading gives you a blank page. Have Fun!</div>
    </section>

    <section class="stage-shell">
      <div class="stage-scroller">
        <div id="stage">
          <canvas id="gridLayer" aria-hidden="true"></canvas>
          <canvas id="paintLayer"></canvas>
        </div>
      </div>
    </section>
  </main>

  <script>
    /*
      HOW IT WORKS:
      - We stack TWO canvases in the same position.
        • gridLayer (bottom): draws only the grid lines. It never receives clicks.
        • paintLayer (top): holds your colored pixels. You click/drag to paint here.
      - You choose columns & rows, then we set canvas size = (cols * CELL_SIZE, rows * CELL_SIZE).
        If that’s larger than your window, the outer container scrolls — the square size never changes.
      - Download button composites a new, hidden canvas and optionally draws the grid before the pixels.
    */

    // ======= Config ========================================================
    const CELL_SIZE = 24; // pixels per square (constant; change if you want bigger/smaller cells)
    const DPR = window.devicePixelRatio || 1; // for crisp lines on HiDPI displays

    // ======= Elements ======================================================
    const stage = document.getElementById('stage');
    const gridEl = document.getElementById('gridLayer');
    const paintEl = document.getElementById('paintLayer');

    const colsInput = document.getElementById('cols');
    const rowsInput = document.getElementById('rows');

    const colorInput = document.getElementById('color');
    const eraserChk = document.getElementById('eraser');
    const showGridChk = document.getElementById('showGrid');
    const dlGridChk = document.getElementById('dlGrid');

    const buildBtn = document.getElementById('build');
    const clearBtn = document.getElementById('clear');
    const downloadBtn = document.getElementById('download');

    // ======= State =========================================================
    let state = {
      cols: 24,
      rows: 24,
      drawing: false,
      lastCellKey: null,
    };

    // ======= Helpers: size & drawing contexts ==============================
    function setCanvasSize(canvas, cssW, cssH) {
      // Backing store pixels (width/height) include DPR for crispness.
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width = Math.floor(cssW * DPR);
      canvas.height = Math.floor(cssH * DPR);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale 1 canvas unit = 1 CSS pixel
      return ctx;
    }

    function resizeStage(cols, rows) {
      const cssW = cols * CELL_SIZE;
      const cssH = rows * CELL_SIZE;
      stage.style.width = cssW + 'px';
      stage.style.height = cssH + 'px';
      const gtx = setCanvasSize(gridEl, cssW, cssH);
      const ptx = setCanvasSize(paintEl, cssW, cssH);
      return { gtx, ptx };
    }

    // ======= Grid drawing ==================================================
    function drawGridToContext(ctx, cols, rows) {
      ctx.clearRect(0, 0, cols * CELL_SIZE, rows * CELL_SIZE);
      ctx.save();
      ctx.lineWidth = 1; ctx.strokeStyle = '#c9ccd1';
      // vertical lines
      for (let c = 0; c <= cols; c++) {
        const x = c * CELL_SIZE + 0.5; // 0.5 makes 1px lines crisp
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, rows * CELL_SIZE); ctx.stroke();
      }
      // horizontal lines
      for (let r = 0; r <= rows; r++) {
        const y = r * CELL_SIZE + 0.5;
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cols * CELL_SIZE, y); ctx.stroke();
      }
      ctx.restore();
    }

    function drawGrid() {
      const gtx = gridEl.getContext('2d');
      drawGridToContext(gtx, state.cols, state.rows);
    }

    // ======= Painting (single‑cell fill & erase) ===========================
    function cellFromEvent(evt) {
      const rect = paintEl.getBoundingClientRect();
      const x = Math.floor((evt.clientX - rect.left) / CELL_SIZE);
      const y = Math.floor((evt.clientY - rect.top) / CELL_SIZE);
      const cx = Math.min(Math.max(x, 0), state.cols - 1);
      const cy = Math.min(Math.max(y, 0), state.rows - 1);
      return { cx, cy };
    }

    function keyForCell(cx, cy) { return cx + ':' + cy; }

    function fillCell(cx, cy, color) {
      const ctx = paintEl.getContext('2d');
      ctx.fillStyle = color;
      ctx.fillRect(cx * CELL_SIZE, cy * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }

    function eraseCell(cx, cy) {
      const ctx = paintEl.getContext('2d');
      ctx.clearRect(cx * CELL_SIZE, cy * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }

    function handlePaint(evt) {
      const { cx, cy } = cellFromEvent(evt);
      const key = keyForCell(cx, cy);
      if (key === state.lastCellKey) return; // skip repeat work while dragging within same cell
      state.lastCellKey = key;
      if (eraserChk.checked) {
        eraseCell(cx, cy);
      } else {
        fillCell(cx, cy, colorInput.value);
      }
    }

    // Pointer events so it works with mouse, pen, or touch
    paintEl.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      state.drawing = true; state.lastCellKey = null;
      paintEl.setPointerCapture(e.pointerId);
      handlePaint(e);
    });
    paintEl.addEventListener('pointermove', (e) => { if (!state.drawing) return; handlePaint(e); });
    window.addEventListener('pointerup', () => { state.drawing = false; state.lastCellKey = null; });
    window.addEventListener('pointercancel', () => { state.drawing = false; state.lastCellKey = null; });

    // ======= Commands (build, clear, show grid, download) ==================
    function build() {
      const cols = Math.max(1, Math.min(200, parseInt(colsInput.value || '1', 10)));
      const rows = Math.max(1, Math.min(200, parseInt(rowsInput.value || '1', 10)));
      state.cols = cols; state.rows = rows;
      const { ptx } = resizeStage(cols, rows);
      // new canvas => clear paint layer and draw fresh grid
      ptx.clearRect(0, 0, cols * CELL_SIZE, rows * CELL_SIZE);
      drawGrid();
    }

    function clearPaint() {
      const ctx = paintEl.getContext('2d');
      ctx.clearRect(0, 0, state.cols * CELL_SIZE, state.rows * CELL_SIZE);
    }

    function setGridVisible(on) {
      gridEl.style.visibility = on ? 'visible' : 'hidden';
    }

    function downloadPNG() {
      // Composite into an offscreen canvas exactly sized to the art in CSS pixels
      const out = document.createElement('canvas');
      out.width = state.cols * CELL_SIZE;
      out.height = state.rows * CELL_SIZE;
      const ctx = out.getContext('2d');

      if (dlGridChk.checked) {
        drawGridToContext(ctx, state.cols, state.rows); // redraw grid so it’s pixel‑perfect
      }
      // Draw the paint layer image. paintEl is HiDPI‑scaled, so drawImage with source size in CSS pixels
      const srcW = paintEl.width / DPR, srcH = paintEl.height / DPR;
      ctx.drawImage(paintEl, 0, 0, srcW, srcH, 0, 0, out.width, out.height);

      const url = out.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url; a.download = 'pixel-art.png';
      document.body.appendChild(a); a.click(); a.remove();
    }

    // Wire up controls
    buildBtn.addEventListener('click', build);
    clearBtn.addEventListener('click', clearPaint);
    showGridChk.addEventListener('change', () => setGridVisible(showGridChk.checked));
    downloadBtn.addEventListener('click', downloadPNG);

    // Initialize once on load
    build();
  </script>
</body>
</html>
